"""Telemetry and metrics collection."""

import logging
import time
from datetime import datetime
from typing import Any, Dict, List, Optional

from .config import TelemetryConfig
from .llm import ModelRegistry

logger = logging.getLogger(__name__)


class TelemetryCollector:
    """Collects and manages telemetry data during processing."""
    
    def __init__(self, config: TelemetryConfig):
        self.config = config
        self.enabled = config.enabled
        
        # Initialize counters
        self.start_time = time.time()
        self.tokens_used = 0
        self.estimated_cost = 0.0
        self.cache_hits = 0
        self.api_calls = 0
        
        # Strategy-level metrics
        self.strategy_metrics: Dict[str, Dict[str, Any]] = {}
        
        # Processing metrics
        self.pdf_count = 0
        self.chunk_count = 0
        self.card_count = 0
        self.error_count = 0
        
        # Timing metrics
        self.phase_timings: Dict[str, float] = {}
        self.current_phase_start: Optional[float] = None
        self.current_phase_name: Optional[str] = None
    
    def start_phase(self, phase_name: str) -> None:
        """Start timing a processing phase."""
        if not self.enabled:
            return
        
        # End previous phase if it exists
        if self.current_phase_name and self.current_phase_start:
            self.end_phase()
        
        self.current_phase_name = phase_name
        self.current_phase_start = time.time()
        logger.debug(f"Starting phase: {phase_name}")
    
    def end_phase(self) -> None:
        """End timing the current processing phase."""
        if not self.enabled or not self.current_phase_name or not self.current_phase_start:
            return
        
        duration = time.time() - self.current_phase_start
        self.phase_timings[self.current_phase_name] = duration
        logger.debug(f"Completed phase: {self.current_phase_name} in {duration:.2f}s")
        
        self.current_phase_name = None
        self.current_phase_start = None
    
    def record_pdf_processed(self) -> None:
        """Record that a PDF was processed."""
        if self.enabled:
            self.pdf_count += 1
    
    def record_chunk_processed(self) -> None:
        """Record that a chunk was processed."""
        if self.enabled:
            self.chunk_count += 1
    
    def record_cards_generated(self, count: int, strategy: str) -> None:
        """Record cards generated by a strategy."""
        if not self.enabled:
            return
        
        self.card_count += count
        
        if strategy not in self.strategy_metrics:
            self.strategy_metrics[strategy] = {
                "cards_generated": 0,
                "chunks_processed": 0,
                "tokens_used": 0,
                "estimated_cost": 0.0,
                "cache_hits": 0,
                "api_calls": 0,
                "errors": 0,
            }
        
        self.strategy_metrics[strategy]["cards_generated"] += count
    
    def record_strategy_metrics(self, strategy: str, llm_stats: Dict[str, Any]) -> None:
        """Record LLM usage metrics for a strategy."""
        if not self.enabled:
            return
        
        if strategy not in self.strategy_metrics:
            self.strategy_metrics[strategy] = {
                "cards_generated": 0,
                "chunks_processed": 0,
                "tokens_used": 0,
                "estimated_cost": 0.0,
                "cache_hits": 0,
                "api_calls": 0,
                "errors": 0,
            }
        
        metrics = self.strategy_metrics[strategy]
        metrics["chunks_processed"] += 1
        metrics["tokens_used"] += llm_stats.get("total_tokens", 0)
        metrics["estimated_cost"] += llm_stats.get("total_cost", 0.0)
        metrics["cache_hits"] += llm_stats.get("cache_hits", 0)
        metrics["api_calls"] += llm_stats.get("api_calls", 0)
        
        # Update global counters
        self.tokens_used += llm_stats.get("total_tokens", 0)
        self.estimated_cost += llm_stats.get("total_cost", 0.0)
        self.cache_hits += llm_stats.get("cache_hits", 0)
        self.api_calls += llm_stats.get("api_calls", 0)
    
    def record_error(self, error_type: str, strategy: Optional[str] = None) -> None:
        """Record an error occurrence."""
        if not self.enabled:
            return
        
        self.error_count += 1
        
        if strategy and strategy in self.strategy_metrics:
            self.strategy_metrics[strategy]["errors"] += 1
    
    def get_manifest_data(self, model_name: str = None) -> Dict[str, Any]:
        """Get telemetry data for inclusion in manifest."""
        if not self.enabled:
            return {}
        
        # End current phase if still running
        if self.current_phase_name:
            self.end_phase()
        
        total_duration = time.time() - self.start_time
        
        manifest = {
            "telemetry": {
                "enabled": True,
                "generated_at": datetime.now().isoformat(),
                "total_duration_seconds": round(total_duration, 2),
                "phase_timings": {k: round(v, 2) for k, v in self.phase_timings.items()},
            }
        }
        
        # Add token and cost tracking if enabled
        if self.config.track_tokens:
            manifest["telemetry"]["tokens"] = {
                "total_used": self.tokens_used,
                "by_strategy": {
                    strategy: metrics["tokens_used"]
                    for strategy, metrics in self.strategy_metrics.items()
                }
            }
        
        if self.config.track_costs:
            manifest["telemetry"]["costs"] = {
                "total_estimated": round(self.estimated_cost, 4),
                "by_strategy": {
                    strategy: round(metrics["estimated_cost"], 4)
                    for strategy, metrics in self.strategy_metrics.items()
                },
                "model": model_name or "unknown"
            }
        
        if self.config.track_cache_hits:
            cache_hit_rate = self.cache_hits / max(1, self.api_calls)
            manifest["telemetry"]["cache"] = {
                "hits": self.cache_hits,
                "total_calls": self.api_calls,
                "hit_rate": round(cache_hit_rate, 3),
                "by_strategy": {
                    strategy: {
                        "hits": metrics["cache_hits"],
                        "calls": metrics["api_calls"],
                        "hit_rate": round(metrics["cache_hits"] / max(1, metrics["api_calls"]), 3)
                    }
                    for strategy, metrics in self.strategy_metrics.items()
                }
            }
        
        # Add processing metrics
        manifest["telemetry"]["processing"] = {
            "pdfs_processed": self.pdf_count,
            "chunks_processed": self.chunk_count,
            "cards_generated": self.card_count,
            "errors": self.error_count,
            "strategies_used": list(self.strategy_metrics.keys()),
        }
        
        # Add strategy breakdown
        if self.strategy_metrics:
            manifest["telemetry"]["strategies"] = {
                strategy: {
                    "cards_generated": metrics["cards_generated"],
                    "chunks_processed": metrics["chunks_processed"],
                    "errors": metrics["errors"],
                }
                for strategy, metrics in self.strategy_metrics.items()
            }
        
        return manifest
    
    def log_summary(self) -> None:
        """Log a summary of telemetry data."""
        if not self.enabled:
            return
        
        total_duration = time.time() - self.start_time
        
        logger.info("=== Processing Summary ===")
        logger.info(f"Total duration: {total_duration:.2f}s")
        logger.info(f"PDFs processed: {self.pdf_count}")
        logger.info(f"Chunks processed: {self.chunk_count}")
        logger.info(f"Cards generated: {self.card_count}")
        
        if self.config.track_tokens:
            logger.info(f"Tokens used: {self.tokens_used:,}")
        
        if self.config.track_costs:
            logger.info(f"Estimated cost: ${self.estimated_cost:.4f}")
        
        if self.config.track_cache_hits and self.api_calls > 0:
            cache_rate = self.cache_hits / self.api_calls * 100
            logger.info(f"Cache hit rate: {cache_rate:.1f}% ({self.cache_hits}/{self.api_calls})")
        
        if self.error_count > 0:
            logger.warning(f"Errors encountered: {self.error_count}")
        
        # Log strategy breakdown
        if self.strategy_metrics:
            logger.info("=== Strategy Breakdown ===")
            for strategy, metrics in self.strategy_metrics.items():
                logger.info(f"{strategy}:")
                logger.info(f"  Cards generated: {metrics['cards_generated']}")
                logger.info(f"  Chunks processed: {metrics['chunks_processed']}")
                if self.config.track_tokens:
                    logger.info(f"  Tokens used: {metrics['tokens_used']:,}")
                if self.config.track_costs:
                    logger.info(f"  Estimated cost: ${metrics['estimated_cost']:.4f}")
        
        # Log phase timings
        if self.phase_timings:
            logger.info("=== Phase Timings ===")
            for phase, duration in self.phase_timings.items():
                percentage = (duration / total_duration) * 100
                logger.info(f"{phase}: {duration:.2f}s ({percentage:.1f}%)")


def create_telemetry_collector(config: TelemetryConfig) -> TelemetryCollector:
    """Factory function to create a telemetry collector."""
    return TelemetryCollector(config)